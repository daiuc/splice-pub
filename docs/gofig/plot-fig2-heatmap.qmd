---
title: Figure 2 - Heatmap of unprodoctive splicing by tissues
date: '2024-08-21'
code-fold: true
execute:
  include: false
  eval: false
  echo: false
  warning: false
  message: false
categories:
  - figures
  - manuscript
---

Heatmap of PSI of unproductive splicing for introns that are commonly differentially spliced across tissues.

::: {.callout-note}
## Notes

* Use GTEx dataset

:::





```{r}
#| eval: false
#| echo: false
httpgd::hgd(host = "10.50.250.200", port = 9696, token = FALSE)
```


```{r}
#| label: setup
#| eval: true

suppressMessages(library(tidyverse))
suppressMessages(library(glue))
suppressMessages(library(data.table))
suppressMessages(library(ComplexHeatmap))

suppressMessages(library(cowplot))
theme_set(theme_cowplot(font_size = 14, font_family = "Helvetica"))

suppressMessages(library(furrr))
plan(multisession, workers = min(4, availableCores()))


# functions
GetHeatmapMatrix <- function(dt, clusters, contrast) {
  # dt$intron2 <- str_replace_all(dt$intron, ":clu_\\d+_", "")
  tissues <- str_split(contrast, "_v_") %>% unlist()
  keep1 <- c("intron", "cluster", tissues[1], "itype", "ctype")
  keep2 <- c("intron", "cluster", tissues[2], "itype", "ctype")
  out <- list(
    dt[cluster %in% clusters, keep1, with = FALSE],
    dt[cluster %in% clusters, keep2, with = FALSE]
  )
  names(out) <- tissues

  return(out)
}


GetTopUpIntrons <- function(data, FDR_ds, FDR_dge, dPSI) {
  dge <- data$dge
  ds <- data$ds

  # if a cluster has multiple UP introns, only select the best 1
  ds <- ds[itype == 'UP' & ctype == 'PR,UP'][, rk := rank(-abs(deltapsi), ties.method = "first"), by = cluster][rk ==1][, rk := NULL][]
  ds <- ds[`p.adjust` < FDR_ds & abs(deltapsi) > dPSI,]

  dge <- dge[padj < FDR_dge,]
  
  ds_excl_cols <- c('itype', 'ctype', 'df', 'p', 'p.adjust','logef', 'loglr', 'status')
  dge_excl_cols <- c('baseMean', 'lfcSE', 'stat', 'pvalue', 'padj')
  chosen <- inner_join(
      x = ds[, -ds_excl_cols, with = FALSE],
      y = dge[, -dge_excl_cols, with = FALSE],
      by = "gene_id",
      suffix = c("_ds", "_dge")
    ) %>%
    .[deltapsi * log2FoldChange < 0, ]

  return(chosen)
}

sumPSI <- function(dt, cn) {
  dt <- rename(dt, psi = {{ cn }})  %>% as.data.table
  dt <- dt[itype == "UP"][, .(psi = sum(psi)), by = cluster] # sum unprod PSI by cluster
  names(dt) <- c("cluster", cn)
  return(as.data.table(dt))
}

```

## Select a union set of unproductive intron clusters

Choose introns based on the following criteria:
1. ds FDR 0.001
2. deltaPSI 0.2 
3. dge FDR 0.05
4. select the best unprod. intron from each cluster, then collect cluster ID

```{r}
#| label: load_data
#| eval: true
#| cache: true

#--- load prepped data
# prepared according to "../../SpliFi/prepdata.smk"
# each data item is a list of 3 df: results of ds, dge, and metadata of dge
data = read_rds("../../SpliFi/data/ds_v_dge/all_contrast_data.rds")

# chosen clusters is union of clusters from each ds contrast, selected based on 
# top unproductive introns
chosen_clusters = read_rds("../../SpliFi/data/ds_v_dge/chosen_clusters_dpsi_0_2.rds")

# tissue code
tissue_code = fread("../analysis/gtex-tissue-code.csv",
  sep=",",
  col.names = c("tissue", "code"),
  header = FALSE)

# clusters to plot are a common set of clusters across tissues
plot_clusters = map(data, ~.x$ds[, cluster]) %>% 
  map(., ~intersect(.x, chosen_clusters)) %>% 
  reduce(intersect)

#--- data used for heatmap plotting
# using chosen plot_clusters to get heatmap matrix from ds results (PSI)
plot_data = imap(data, ~GetHeatmapMatrix(.x$ds, plot_clusters, .y)) %>% 
  unlist(recursive = FALSE)

# get the names of stored plot datatable without duplicating dataste
plot_data.names <- names(plot_data) %>%
  str_split("\\.", simplify = T) %>%
  as.data.table() %>%
  .[, .(V1, V2, rk = rank(V1)), by = V2] %>% # after split, V1=contrast, V2=tissue
  .[rk == 1] %>% # since a tissue can be used in multiple contrasts, only keep 1
  .[, .(V1, nm = paste(V1, ".", V2, sep = ""))] %>%
  .[, nm]

# reduce dataset to only the selected tissues
plot_data <- plot_data[plot_data.names]
names(plot_data) <- str_split(names(plot_data), "\\.") %>% map_chr(~.[2])

# summ PSI to get a single value for each cluster
plot_data = imap(plot_data, ~sumPSI(.x, .y))

# remove large objects
rm(data)

```

```{r}
#| label: prepare heatmap matrix
#| eval: true
#| cache: true

#--- further reduce plot data to makit heatmap ready
mx_clusters = intersect(
  map(plot_data, pluck, "cluster") %>% reduce(intersect),
  plot_clusters
)
mx_clusters = naturalsort::naturalsort(mx_clusters)

# jointo ensure same cluster, same order across tissues
plot_data = map(plot_data, \(df) {
  left_join(
    x = data.table(cluster = mx_clusters),
    y = df,
    by = "cluster",
    multiple = "any"
  )
})

if (all(map_lgl(plot_data, ~all(!is.na(pluck(.x, 2)))))) {
  print("Ready to plot heatmap")
} else {
  stop("Cluster order is not consistent across tissues")
}

# construct heatmap matrix
mx = cbind(plot_data[[1]][,1], map_dfc(plot_data, ~.x[,2]))

# replace tissue with tissue code
lookup = deframe(tissue_code) %>% c("cluster"="cluster", .)
colnames(mx) = lookup[colnames(mx)]

```


```{r}
#| label: plot heatmap
#| eval: true
#| cache: true

legendBreaks <- seq(-4, 4, 2)
# colors <- rev(RColorBrewer::brewer.pal(length(legendBreaks), "RdBu"))
colors <- c("#053061", "#2166AC", "#F7F7F7", "#B2182B", "#67001F")
colfunc <- circlize::colorRamp2(
  breaks = legendBreaks, 
  colors = colors
  )

cluster_method = "ward.D2"
set.seed(123)
ht <- mx %>%
  column_to_rownames("cluster") %>%
  as.matrix %>% t %>% scale %>% t %>%
  Heatmap(
    col = colfunc,
    row_km = 12, row_gap = unit(0.2, "mm"), 
    column_km = 3, column_gap = unit(0.2, "mm"),
    show_parent_dend_line = FALSE,
    show_row_names = FALSE, clustering_method_rows = cluster_method, show_row_dend = F,
    clustering_method_columns = cluster_method, column_dend_height = unit(1.5, "in"), show_column_dend = TRUE,
    heatmap_legend_param = list(title = "PSI (z-score)"),
    use_raster = TRUE
    )

```

```{r}
#| eval: true
#| include: true

print(glue("Number of clusters to plot: {length(mx_clusters)}"))
# map(plot_data, ~.x[, cluster]) %>% reduce(intersect) %>% length
```


```{r}
# save ht to a svg file
svg("plot-fig2-heatmap.svg", width = 8, height = 8)
ht
dev.off()
```

```{r}
#| label: fig-heatmap
#| eval: true
#| include: true
#| column: page
#| out-width: 100%
#| fig-cap: "Heatmap of unproductive splicing by tissues"

knitr::include_graphics("plot-fig2-heatmap.svg")
```
















